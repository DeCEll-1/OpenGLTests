// <auto-generated/>
namespace RGL.Generated.Paths;
public static class RGLResources
{
    public static class Shaders
    {
        public static class MCSDF
        {
            public const string Name = "MCSDF";
            public const string Fragment = "Resources/Shaders/RenderShaders/MCSDF/MCSDF.frag";
            public const string FragmentFileContent = "#version 330 core\n\nin vec2 texCoord;\nout vec4 color;\nuniform sampler2D msdf;\nuniform vec4 bgColor;\nuniform vec4 fgColor;\n\nuniform float pxRange; // set to distance field's pixel range\n\nfloat screenPxRange() {\n    vec2 unitRange = vec2(pxRange) / vec2(textureSize(msdf, 0));\n    vec2 screenTexSize = vec2(1.0) / fwidth(texCoord);\n    return max(0.5 * dot(unitRange, screenTexSize), 1.0);\n}\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nvoid main() {\n    vec3 msd = texture(msdf, texCoord).rgb;\n    float sd = median(msd.r, msd.g, msd.b);\n    float screenPxDistance = screenPxRange() * (sd - 0.5);\n    float opacity = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n    vec4 mixedCol = mix(bgColor, fgColor, opacity);\n    color = vec4(mixedCol);\n}\n";
            public const string Vertex = "Resources/Shaders/RenderShaders/MCSDF/MCSDF.vert";
            public const string VertexFileContent = "#version 330 core\n\nlayout(location = 0) in vec3 aPos;\nlayout(location = 1) in vec2 aTex;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nout vec2 texCoord;\n\nvoid main()\n{\n    texCoord = aTex;\n    gl_Position = vec4(aPos, 1.0) * model * view * projection;\n}\n";
        }
        public static class Phong
        {
            public const string Name = "Phong";
            public const string Fragment = "Resources/Shaders/RenderShaders/Phong/Phong.frag";
            public const string FragmentFileContent = "#version 330 core\n\nin vec3 FragPos0; // moved frag pos\nin vec3 Normal0; // normals from the cpu\nflat in vec3 flatNormal0; // normals from the cpu\nin vec2 TexCoord0;\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\nuniform Material material;\n\n//The light contains all the values from the light source, how the ambient diffuse and specular values are from the light source.\n//This is technically what we were using in the last episode as we were only applying the phong model directly to the light.\nstruct Light {\n    vec3 position;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nuniform Light light;\n\nuniform vec3 viewPos; // camera\n\nout vec4 FragColor;\n\nin vec3 EdgeDistance0;\n\nvoid main()\n{\n    //ambient\n    vec3 ambient = light.ambient * material.ambient; //Remember to use the material here.\n\n    //diffuse\n    vec3 norm = normalize(Normal0);\n    vec3 lightDir = normalize(light.position - FragPos0);\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = light.diffuse * (diff * material.diffuse); //Remember to use the material here.\n\n    //specular\n    vec3 viewDir = normalize(viewPos - FragPos0);\n    vec3 reflectDir = reflect(-lightDir, norm);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    vec3 specular = light.specular * (spec * material.specular); //Remember to use the material here.\n\n    //Now the result sum has changed a bit, since we now set the objects color in each element, we now dont have to\n    //multiply the light with the object here, instead we do it for each element seperatly. This allows much better control\n    //over how each element is applied to different objects.\n    vec3 result = ambient + diffuse + specular;\n\n    float d = min(EdgeDistance0.x, min(EdgeDistance0.y, EdgeDistance0.z)) * 3.;\n\n    // if (d < .05)\n    //     result = vec3(1.);\n    // else\n    //     result = vec3(0.);\n\n    FragColor = vec4(result, 1.);\n}\n";
            public const string Vertex = "Resources/Shaders/RenderShaders/Phong/Phong.vert";
            public const string VertexFileContent = "#version 330 core\nlayout(location = 0) in vec3 aPos;\nlayout(location = 1) in vec3 aNormal;\nlayout(location = 2) in vec2 aTexCoord;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nout vec3 FragPos; // Position to fragment shader\nout vec3 Normal; // Normal to fragment shader\nflat out vec3 flatNormal; // non interpolarated normal for flat shading\nout vec2 TexCoord; // Texture coordinates to fragment shader\n\nvoid main()\n{\n    FragPos = vec3(vec4(aPos, 1.0) * model); // Calculate world position\n    flatNormal = Normal = normalize(mat3(transpose(inverse(model))) * aNormal);\n    // Normal = mat3(transpose(inverse(model))) * aNormal; // Transform normal to world space\n    TexCoord = aTexCoord; // Pass texture coordinates\n\n    // note that we read the multiplication from right to left\n    gl_Position = vec4(aPos, 1.0) * model * view * projection;\n    // gl_Position = vec4(aPos, 1.0) * projection * view * model;\n}\n";
            public const string Geometry = "Resources/Shaders/RenderShaders/Phong/Phong.geom";
            public const string GeometryFileContent = "#version 330\n\nlayout(triangles) in;\nlayout(triangle_strip) out;\nlayout(max_vertices = 3) out;\n\nin vec3 FragPos[];\nin vec3 Normal[];\nflat in vec3 flatNormal[];\nin vec2 TexCoord[];\n\nout vec3 FragPos0; // moved frag pos\nout vec3 Normal0; // normals from the cpu\nflat out vec3 flatNormal0; // normals from the cpu\nout vec2 TexCoord0;\n\nout vec3 EdgeDistance0;\n\nvoid updateVars(int i) {\n    FragPos0 = FragPos[i];\n    Normal0 = Normal[i];\n    flatNormal0 = flatNormal[i];\n    TexCoord0 = TexCoord[i];\n}\n\nvoid main()\n{\n    // i really, dont know why https://developer.download.nvidia.com/SDK/10/direct3d/Source/SolidWireframe/Doc/SolidWireframe.pdf\n    // makes all these calculations, you can just put 1s in the triangles points and it interpolerates anyways?\n\n    // #region obsolete\n    // // vec4 p;\n\n    // // p = gl_in[0].gl_Position;\n    // // vec2 p0 = vec2(gViewportMatrix * (p / p.w));\n\n    // // p = gl_in[1].gl_Position;\n    // // vec2 p1 = vec2(gViewportMatrix * (p / p.w));\n\n    // // p = gl_in[2].gl_Position;\n    // // vec2 p2 = vec2(gViewportMatrix * (p / p.w));\n\n    // // float a = length(p1 - p2);\n    // // float b = length(p2 - p0);\n    // // float c = length(p1 - p0);\n\n    // // float alpha = acos((b * b + c * c - a * a) / (2.0 * b * c));\n    // // float beta = acos((a * a + c * c - b * b) / (2.0 * a * c));\n\n    // // float ha = abs(c * sin(beta));\n    // // float hb = abs(c * sin(alpha));\n    // // float hc = abs(b * sin(alpha));\n    // #endregion\n\n    // #region first vertex of the triangle\n    gl_Position = gl_in[0].gl_Position;\n    gl_ClipDistance = gl_in[0].gl_ClipDistance;\n\n    updateVars(0);\n\n    EdgeDistance0 = vec3(1., 0.0, 0.0);\n    EmitVertex();\n    // #endregion\n\n    // #region second vertex of the triangle\n    gl_Position = gl_in[1].gl_Position;\n    gl_ClipDistance = gl_in[1].gl_ClipDistance;\n\n    updateVars(1);\n\n    EdgeDistance0 = vec3(0.0, 1., 0.0);\n    EmitVertex();\n    // #endregion\n\n    // #region third vertex of the triangle\n    gl_Position = gl_in[2].gl_Position;\n    gl_ClipDistance = gl_in[2].gl_ClipDistance;\n\n    updateVars(2);\n\n    EdgeDistance0 = vec3(0.0, 0.0, 1.);\n    EmitVertex();\n    // #endregion\n\n    EndPrimitive();\n}\n";
        }
        public static class Texture
        {
            public const string Name = "Texture";
            public const string Fragment = "Resources/Shaders/RenderShaders/Texture/Texture.frag";
            public const string FragmentFileContent = "#version 330 core\n\nin vec3 FragPos; // moved frag pos\nin vec3 Normal; // normals from the cpu\nin vec2 TexCoord; // tex coordinates from the cpu\n\nstruct Material {\n    sampler2D texture; // tex\n    vec4 colMultiplier; // color multiplier\n};\n\nuniform Material material;\n\nout vec4 FragColor;\n\nvoid main()\n{\n    vec4 col = texture(material.texture, TexCoord);\n\n    // Apply lighting to the texture color\n    FragColor = vec4(col * material.colMultiplier);\n}\n";
            public const string Vertex = "Resources/Shaders/RenderShaders/Texture/Texture.vert";
            public const string VertexFileContent = "#version 330 core\nlayout(location = 0) in vec3 aPos;\nlayout(location = 1) in vec3 aNormal;\nlayout(location = 2) in vec2 aTexCoord;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nout vec3 FragPos; // Position to fragment shader\nout vec3 Normal; // Normal to fragment shader\nout vec2 TexCoord; // Texture coordinates to fragment shader\n\nvoid main()\n{\n    FragPos = vec3(vec4(aPos, 1.0) * model); // Calculate world position\n    Normal = normalize(mat3(transpose(inverse(model))) * aNormal);\n    // Normal = mat3(transpose(inverse(model))) * aNormal; // Transform normal to world space\n    TexCoord = aTexCoord; // Pass texture coordinates\n\n    // note that we read the multiplication from right to left\n    gl_Position = vec4(aPos, 1.0) * model * view * projection;\n    // gl_Position = vec4(aPos, 1.0) * projection * view * model;\n}\n";
        }
        public static class MonoColor
        {
            public const string Name = "MonoColor";
            public const string Fragment = "Resources/Shaders/RenderShaders/MonoColor/MonoColor.frag";
            public const string FragmentFileContent = "\n#version 330 core\n\nout vec4 FragColor;\nuniform vec4 color;\n\nvoid main()\n{\n    FragColor = vec4(color);\n}\n";
            public const string Vertex = "Resources/Shaders/RenderShaders/MonoColor/MonoColor.vert";
            public const string VertexFileContent = "\n#version 330 core\nlayout(location = 0) in vec3 aPos;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nvoid main()\n{\n    // note that we read the multiplication from right to left\n    gl_Position = vec4(aPos, 1.0) * model * view * projection;\n}\n";
        }
        public static class Standart
        {
            public const string Name = "Standart";
            public const string Fragment = "Resources/Shaders/RenderShaders/Standart/Standart.frag";
            public const string FragmentFileContent = "#version 330 core\n\nin vec3 FragPos0; // moved frag pos\nin vec3 Normal0; // normals from the cpu\nflat in vec3 flatNormal0; // normals from the cpu\nin vec2 TexCoord0;\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\nuniform Material material;\n\n//The light contains all the values from the light source, how the ambient diffuse and specular values are from the light source.\n//This is technically what we were using in the last episode as we were only applying the phong model directly to the light.\nstruct Light {\n    vec3 position;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nuniform Light light;\n\nuniform vec3 viewPos; // camera\n\nout vec4 FragColor;\n\nin vec3 EdgeDistance0;\n\nvoid main()\n{\n    //ambient\n    vec3 ambient = light.ambient * material.ambient; //Remember to use the material here.\n\n    //diffuse\n    vec3 norm = normalize(flatNormal0);\n    vec3 lightDir = normalize(light.position - FragPos0);\n    float diff = max(dot(norm, lightDir), 0.0);\n    vec3 diffuse = light.diffuse * (diff * material.diffuse); //Remember to use the material here.\n\n    //specular\n    vec3 viewDir = normalize(viewPos - FragPos0);\n    vec3 reflectDir = reflect(-lightDir, norm);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    vec3 specular = light.specular * (spec * material.specular); //Remember to use the material here.\n\n    //Now the result sum has changed a bit, since we now set the objects color in each element, we now dont have to\n    //multiply the light with the object here, instead we do it for each element seperatly. This allows much better control\n    //over how each element is applied to different objects.\n    vec3 result = ambient + diffuse + specular;\n\n    float d = min(EdgeDistance0.x, min(EdgeDistance0.y, EdgeDistance0.z));\n\n    if (d < 0.01)\n        result = vec3(1.);\n    else\n        result = vec3(0.);\n\n    FragColor = vec4(result, 1.);\n}\n";
            public const string Vertex = "Resources/Shaders/RenderShaders/Standart/Standart.vert";
            public const string VertexFileContent = "#version 330 core\nlayout(location = 0) in vec3 aPos;\nlayout(location = 1) in vec3 aNormal;\nlayout(location = 2) in vec2 aTexCoord;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 projection;\n\nout vec3 FragPos; // Position to fragment shader\nout vec3 Normal; // Normal to fragment shader\nflat out vec3 flatNormal; // non interpolarated normal for flat shading\nout vec2 TexCoord; // Texture coordinates to fragment shader\n\nvoid main()\n{\n    FragPos = vec3(vec4(aPos, 1.0) * model); // Calculate world position\n    flatNormal = Normal = normalize(mat3(transpose(inverse(model))) * aNormal);\n    // Normal = mat3(transpose(inverse(model))) * aNormal; // Transform normal to world space\n    TexCoord = aTexCoord; // Pass texture coordinates\n\n    // note that we read the multiplication from right to left\n    gl_Position = vec4(aPos, 1.0) * model * view * projection;\n    // gl_Position = vec4(aPos, 1.0) * projection * view * model;\n}\n";
            public const string Geometry = "Resources/Shaders/RenderShaders/Standart/Standart.geom";
            public const string GeometryFileContent = "#version 330\n\nlayout(triangles) in;\nlayout(triangle_strip) out;\nlayout(max_vertices = 3) out;\n\nin vec3 FragPos[];\nin vec3 Normal[];\nflat in vec3 flatNormal[];\nin vec2 TexCoord[];\n\nout vec3 FragPos0; // moved frag pos\nout vec3 Normal0; // normals from the cpu\nflat out vec3 flatNormal0; // normals from the cpu\nout vec2 TexCoord0;\n\nout vec3 EdgeDistance0;\n\nvoid updateVars(int i) {\n    FragPos0 = FragPos[i];\n    Normal0 = Normal[i];\n    flatNormal0 = flatNormal[i];\n    TexCoord0 = TexCoord[i];\n}\n\nvoid main()\n{\n    // i really, dont know why https://developer.download.nvidia.com/SDK/10/direct3d/Source/SolidWireframe/Doc/SolidWireframe.pdf\n    // makes all these calculations, you can just put 1s in the triangles points and it interpolerates anyways?\n\n    // #region first vertex of the triangle\n    gl_Position = gl_in[0].gl_Position;\n    gl_ClipDistance = gl_in[0].gl_ClipDistance;\n\n    updateVars(0);\n\n    EdgeDistance0 = vec3(1., 0.0, 0.0);\n    EmitVertex();\n    // #endregion\n\n    // #region second vertex of the triangle\n    gl_Position = gl_in[1].gl_Position;\n    gl_ClipDistance = gl_in[1].gl_ClipDistance;\n\n    updateVars(1);\n\n    EdgeDistance0 = vec3(0.0, 1., 0.0);\n    EmitVertex();\n    // #endregion\n\n    // #region third vertex of the triangle\n    gl_Position = gl_in[2].gl_Position;\n    gl_ClipDistance = gl_in[2].gl_ClipDistance;\n\n    updateVars(2);\n\n    EdgeDistance0 = vec3(0.0, 0.0, 1.);\n    EmitVertex();\n    // #endregion\n\n    EndPrimitive();\n}\n";
        }
        public static class Skybox
        {
            public const string Name = "Skybox";
            public const string Fragment = "Resources/Shaders/RenderShaders/Skybox/Skybox.frag";
            public const string FragmentFileContent = "#version 330 core\nout vec4 FragColor;\n\nin vec3 TexCoord;\n\nuniform samplerCube skybox;\n\nvoid main()\n{\n    FragColor = texture(skybox, TexCoord);\n}\n";
            public const string Vertex = "Resources/Shaders/RenderShaders/Skybox/Skybox.vert";
            public const string VertexFileContent = "\n#version 330 core\nlayout(location = 0) in vec3 aPos;\n\nuniform mat4 view;\nuniform mat4 projection;\n\nout vec3 TexCoord; // Texture coordinates to fragment shader\n\nvoid main()\n{\n    TexCoord = aPos; // Pass texture coordinates\n\n    // note that we read the multiplication from right to left\n    gl_Position = (vec4(aPos, 1.0) * mat4(mat3(view)) * projection).xyww;\n    // gl_Position = vec4(aPos, 1.0) * projection * view * model;\n}\n";
        }
        public static class Model
        {
            public const string Name = "Model";
            public const string Fragment = "Resources/Shaders/RenderShaders/Model/Model.frag";
            public const string FragmentFileContent = "#version 330 core\r\n\r\nin vec3 FragPos; // moved frag pos\r\nin vec3 Normal; // normals from the cpu\r\nin vec2 TexCoord; // tex coordinates from the cpu\r\n\r\nuniform sampler2D color;\r\nuniform sampler2D occlusion;\r\nuniform sampler2D normal; // add this l8r\r\n\r\nout vec4 FragColor;\r\n\r\nvoid main()\r\n{\r\n    vec4 col = texture(color, TexCoord);\r\n    float occ = texture(occlusion, TexCoord).r;\r\n\r\n    vec3 res = vec3(col * occ);\r\n\r\n    // Apply lighting to the texture color\r\n    FragColor = vec4(res, 1.);\r\n}\r\n";
            public const string Vertex = "Resources/Shaders/RenderShaders/Model/Model.vert";
            public const string VertexFileContent = "#version 330 core\r\nlayout(location = 0) in vec3 aPos;\r\nlayout(location = 1) in vec3 aNormal;\r\nlayout(location = 2) in vec2 aTexCoord;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\nout vec3 FragPos; // Position to fragment shader\r\nout vec3 Normal; // Normal to fragment shader\r\nout vec2 TexCoord; // Texture coordinates to fragment shader\r\n\r\nvoid main()\r\n{\r\n    FragPos = vec3(vec4(aPos, 1.0) * model); // Calculate world position\r\n    Normal = normalize(mat3(transpose(inverse(model))) * aNormal);\r\n    TexCoord = aTexCoord; // Pass texture coordinates\r\n\r\n    // note that we read the multiplication from right to left\r\n    gl_Position = vec4(aPos, 1.0) * model * view * projection;\r\n    // gl_Position = vec4(aPos, 1.0) * projection * view * model;\r\n}\r\n";
        }
        public static class PPWriteFBO
        {
            public const string Name = "PPWriteFBO";
            public const string Fragment = "Resources/Shaders/PostProcesses/WriteFBO/WriteFBO.frag";
            public const string FragmentFileContent = "#version 330 core\r\nout vec4 FragColor;\r\n\r\nin vec2 TexCoords;\r\n\r\nuniform sampler2D colorBuffer;\r\n\r\nvoid main()\r\n{\r\n    FragColor = texture(colorBuffer, TexCoords);\r\n}\r\n";
            public const string Vertex = "Resources/Shaders/PostProcesses/MasterVertex.vert";
            public const string VertexFileContent = "#version 330 core\r\nlayout(location = 0) in vec3 aPos;\r\nlayout(location = 2) in vec2 aTexCoord;\r\n\r\nout vec2 TexCoords;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);\r\n    TexCoords = aTexCoord;\r\n}\r\n";
        }
        public static class PPInversion
        {
            public const string Name = "PPInversion";
            public const string Fragment = "Resources/Shaders/PostProcesses/Inversion/Inversion.frag";
            public const string FragmentFileContent = "#version 330 core\r\nout vec4 FragColor;\r\n\r\nin vec2 TexCoords;\r\n\r\nuniform sampler2D colorBuffer;\r\nuniform sampler2D depthBuffer;\r\n\r\nvoid main()\r\n{\r\n    FragColor = vec4(vec3(1.0 - texture(colorBuffer, TexCoords).rgb), 1.0);\r\n}\r\n";
            public const string Vertex = "Resources/Shaders/PostProcesses/MasterVertex.vert";
            public const string VertexFileContent = "#version 330 core\r\nlayout(location = 0) in vec3 aPos;\r\nlayout(location = 2) in vec2 aTexCoord;\r\n\r\nout vec2 TexCoords;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);\r\n    TexCoords = aTexCoord;\r\n}\r\n";
        }
        public static class PPDepthDisplay
        {
            public const string Name = "PPDepthDisplay";
            public const string Fragment = "Resources/Shaders/PostProcesses/DepthDisplay/DepthDisplay.frag";
            public const string FragmentFileContent = "#version 330 core\r\nout vec4 FragColor;\r\n\r\nin vec2 TexCoords;\r\n\r\nuniform sampler2D colorBuffer;\r\nuniform sampler2D depthBuffer;\r\n\r\nuniform vec3 fogColor;\r\n\r\nuniform float near; // Camera near plane\r\nuniform float far; // Camera far plane\r\nuniform float fogDensity; // For exponential fog\r\n\r\n// Convert depth buffer value to linear depth\r\nfloat LinearizeDepth(float depth)\r\n{\r\n    float ndc = depth * 2.0 - 1.0;\r\n    return (2.0 * near * far) / (far + near - ndc * (far - near));\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 color = texture(colorBuffer, TexCoords).rgb;\r\n    float depth = texture(depthBuffer, TexCoords).r;\r\n\r\n    float linearDepth = LinearizeDepth(depth) - 5.;\r\n\r\n    float fogFactor = exp(-fogDensity * linearDepth);\r\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\r\n\r\n    vec3 finalColor = mix(fogColor, color, fogFactor);\r\n    FragColor = vec4(finalColor, 1.0);\r\n}\r\n";
            public const string Vertex = "Resources/Shaders/PostProcesses/MasterVertex.vert";
            public const string VertexFileContent = "#version 330 core\r\nlayout(location = 0) in vec3 aPos;\r\nlayout(location = 2) in vec2 aTexCoord;\r\n\r\nout vec2 TexCoords;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);\r\n    TexCoords = aTexCoord;\r\n}\r\n";
        }
        public static class PPGammaCorrection
        {
            public const string Name = "PPGammaCorrection";
            public const string Fragment = "Resources/Shaders/PostProcesses/GammaCorrection/GammaCorrection.frag";
            public const string FragmentFileContent = "#version 330 core\r\nout vec4 FragColor;\r\n\r\nin vec2 TexCoords;\r\n\r\nuniform sampler2D colorBuffer;\r\nuniform sampler2D depthBuffer;\r\n\r\nuniform float gamma;\r\n\r\nvoid main()\r\n{\r\n    vec3 col = texture(colorBuffer, TexCoords).rgb;\r\n\r\n    col = pow(col, vec3(1.0 / gamma));\r\n\r\n    FragColor = vec4(col, 1.0);\r\n}\r\n";
            public const string Vertex = "Resources/Shaders/PostProcesses/MasterVertex.vert";
            public const string VertexFileContent = "#version 330 core\r\nlayout(location = 0) in vec3 aPos;\r\nlayout(location = 2) in vec2 aTexCoord;\r\n\r\nout vec2 TexCoords;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);\r\n    TexCoords = aTexCoord;\r\n}\r\n";
        }
    }
    public static class ComputeShaders
    {
    }
    public static class Textures
    {
    }
    public static class Fonts
    {
    }
    public static class Cubemaps
    {
    }
    public static class Geometries
    {
        public static class Models
        {
        }
    }
}
